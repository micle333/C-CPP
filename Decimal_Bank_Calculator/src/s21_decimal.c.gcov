        -:    0:Source:s21_decimal.c
        -:    0:Graph:./s21_decimal.gcno
        -:    0:Data:./s21_decimal.gcda
        -:    0:Runs:142
        -:    0:Programs:1
        -:    1:#include "s21_decimal.h"
        -:    2:
    #####:    3:int lengh(int a) {
    #####:    4:  int len = 0;
    #####:    5:  while (a % 10 > 0) {
    #####:    6:    a = a / 10;
    #####:    7:    len++;
        -:    8:  }
    #####:    9:  return len;
        -:   10:}
        -:   11:
        9:   12:int s21_from_float_to_decimal(float src, s21_decimal *dst) {
        9:   13:  int result = 0;  //  Возвращаемая ошибка
        9:   14:  int cap = 0;     //  Наша будущая степень
        9:   15:  long double superfloat = src;
        9:   16:  int microfloat = 0;
       18:   17:  if ((dst == NULL) || (superfloat == INFINITY) || (superfloat == NAN) ||
        9:   18:      (superfloat > 1e28) ||
        9:   19:      (superfloat <
        -:   20:       -1e28))  // Посмотрим на указатель - вдруг null? Тестим наш суперфлоат
        -:   21:  {
    #####:   22:    result = 1;
    #####:   23:  } else {  // Нулим результирующий дец
        9:   24:    dst->bits[0] = 0;
        9:   25:    dst->bits[1] = 0;
        9:   26:    dst->bits[2] = 0;
        9:   27:    dst->bits[3] = 0;
        9:   28:    if (superfloat < 0) {
        1:   29:      superfloat *= -1;
        1:   30:    }
        -:   31:
       78:   32:    while (superfloat < 1000000)  // Следующие два вайла подрежут мантиссу до 7
        -:   33:                                  // цифр - нам нужны только они.
        -:   34:    {
       69:   35:      superfloat *= 10;
       69:   36:      cap++;
        -:   37:    }
       26:   38:    while (superfloat > 9999999) {
       17:   39:      superfloat /= 10;
       17:   40:      cap--;
        -:   41:    }
        9:   42:    microfloat =
        9:   43:        round(superfloat);  //  Эту инту мы будем приводить в бинарный вид
        -:   44:
        9:   45:    int i = 1;
      212:   46:    while (microfloat != 0) {  //  Этот вайлик перегоняет в бинарь
      203:   47:      if (microfloat % 2 == 1) {
       92:   48:        touchbit(dst, i, 1);
       92:   49:        microfloat--;
       92:   50:      } else {
      111:   51:        touchbit(dst, i, 0);
        -:   52:      }
      203:   53:      microfloat /= 2;
      203:   54:      i++;
        -:   55:    }
        9:   56:    while (cap > 28) {  //  Подрезаем сверхбольшие или сверхмалые значения
    #####:   57:      remdivx10(dst);
    #####:   58:      cap--;
        -:   59:    }
       26:   60:    while (cap < 0) {
       17:   61:      x10mant(dst);
       17:   62:      cap++;
        -:   63:    }
        9:   64:    set_cap(dst, cap);  //   Ставим степень и бит отрицалова
        9:   65:    if (src < 0) {
        1:   66:      touchbit(dst, 128, 1);
        1:   67:    }
        -:   68:  }
        9:   69:  return result;
        -:   70:}
        -:   71://   10011001001010101001010101100
        -:   72:
        5:   73:int s21_truncate(s21_decimal value, s21_decimal *result) {
       48:   74:  while (getrank(&value) != 0) {
       43:   75:    divx10(&value);
        -:   76:  }
        5:   77:  *result = value;
        5:   78:  return 0;
        -:   79:}
        -:   80:
      638:   81:int getrank(s21_decimal *dec) {  // Возвразщает разряд в десятичной системе
      638:   82:  int rank = 0;
     5742:   83:  for (int i = 0; i < 8; i++) {
     5104:   84:    rank += s21_getbit(dec, 113 + i) * pow(2, i);
     5104:   85:  }
      638:   86:  return rank;
        -:   87:}
        -:   88:
       12:   89:int s21_is_less(s21_decimal dec1, s21_decimal dec2) {
       12:   90:  int res = 0;
       12:   91:  if (s21_getbit(&dec1, 128) > s21_getbit(&dec2, 128)) {
        1:   92:    res = 1;
       12:   93:  } else if (s21_getbit(&dec1, 128) == s21_getbit(&dec2, 128)) {
       11:   94:    if (getrank(&dec1) != getrank(&dec2)) {
    #####:   95:      normalize(&dec1, &dec2);
    #####:   96:      if (comparison(&dec1, &dec2) == 2) res = 1;
       11:   97:    } else if (getrank(&dec2) == getrank(&dec1)) {
       11:   98:      if (comparison(&dec1, &dec2) == 2) res = 1;
       11:   99:    }
       11:  100:  }
       12:  101:  if (s21_getbit(&dec1, 128) && s21_getbit(&dec2, 128) &&
        5:  102:      !s21_is_equal(dec1, dec2))
        4:  103:    res = invert(res);
       12:  104:  return res;
        -:  105:}
        -:  106:
        7:  107:int s21_is_less_or_equal(s21_decimal dec1, s21_decimal dec2) {
        7:  108:  int res = 0;
        7:  109:  if (s21_is_less(dec1, dec2) || s21_is_equal(dec1, dec2)) {
        5:  110:    res = 1;
        5:  111:  }
        7:  112:  return res;
        -:  113:}
        -:  114:
       92:  115:int s21_is_greater(s21_decimal dec1, s21_decimal dec2) {
       92:  116:  int res = 0;
       92:  117:  if (s21_getbit(&dec1, 128) < s21_getbit(&dec2, 128)) {
        1:  118:    res = 1;
       92:  119:  } else if (s21_getbit(&dec1, 128) == s21_getbit(&dec2, 128)) {
       90:  120:    if (getrank(&dec1) != getrank(&dec2)) {
        2:  121:      normalize(&dec1, &dec2);
        2:  122:      if (comparison(&dec1, &dec2) == 1) res = 1;
       90:  123:    } else if (getrank(&dec2) == getrank(&dec1)) {
       88:  124:      if (comparison(&dec1, &dec2) == 1) res = 1;
       88:  125:    }
       90:  126:  }
       92:  127:  if (s21_getbit(&dec1, 128) && s21_getbit(&dec2, 128) &&
        6:  128:      !s21_is_equal(dec1, dec2))
        4:  129:    res = invert(res);
       92:  130:  return res;
        -:  131:}
        -:  132:
       86:  133:int s21_is_greater_or_equal(s21_decimal dec1, s21_decimal dec2) {
       86:  134:  int res = 0;
       86:  135:  if (s21_is_greater(dec1, dec2) || s21_is_equal(dec1, dec2)) {
       34:  136:    res = 1;
       34:  137:  }
       86:  138:  return res;
        -:  139:}
        -:  140:
        8:  141:int invert(int i) {
        8:  142:  int flag = 0;
        8:  143:  if (i == 0)
        4:  144:    flag = 1;
        4:  145:  else if (i == 1)
        4:  146:    flag = 0;
        8:  147:  return flag;
        -:  148:}
        -:  149:
       96:  150:int s21_is_equal(s21_decimal dec1, s21_decimal dec2) {
       96:  151:  int res = 0;
       96:  152:  normalize(&dec1, &dec2);
      188:  153:  if (s21_getbit(&dec1, 128) == s21_getbit(&dec2, 128) &&
       92:  154:      getrank(&dec1) == getrank(&dec2) && comparison(&dec1, &dec2) == 3) {
       29:  155:    res = 1;
       29:  156:  }
       96:  157:  return res;
        -:  158:}
        -:  159:
        5:  160:int s21_is_not_equal(s21_decimal dec1, s21_decimal dec2) {
        5:  161:  int res = 0;
        5:  162:  normalize(&dec1, &dec2);
        8:  163:  if (s21_getbit(&dec1, 128) != s21_getbit(&dec2, 128) ||
        3:  164:      getrank(&dec1) != getrank(&dec2) || comparison(&dec1, &dec2) != 3) {
        3:  165:    res = 1;
        3:  166:  }
        5:  167:  return res;
        -:  168:}
        -:  169:
      196:  170:int comparison(s21_decimal *dec1, s21_decimal *dec2) {
      196:  171:  int res = 3;
    16109:  172:  for (int i = 96; i > 0; i--) {
    16055:  173:    if (s21_getbit(dec1, i) > s21_getbit(dec2, i)) {
       29:  174:      res = 1;
       29:  175:      break;
    16026:  176:    } else if (s21_getbit(dec1, i) < s21_getbit(dec2, i)) {
      113:  177:      res = 2;
      113:  178:      break;
        -:  179:    }
    15913:  180:  }
      196:  181:  return res;
        -:  182:}
        -:  183:
       43:  184:unsigned int divx10(s21_decimal *dec) {
       43:  185:  unsigned int buffer = 0;
        -:  186:
       43:  187:  int sign = getsig(dec);
       43:  188:  int scalenum = get_cap(dec);
       43:  189:  s21_decimal result = {{0, 0, 0, 0}};
        -:  190:
       43:  191:  int fone = first1(dec);
        -:  192:
     1814:  193:  for (int i = 0; i < fone + 2; i++) {
     1771:  194:    if (buffer >= 10) {
      802:  195:      sleft(&result);
      802:  196:      s21_touchbit(&result, 1, 1);
      802:  197:      buffer = buffer - 10u;
      802:  198:      int nbit = s21_getbit(dec, fone - i + 1);
      802:  199:      buffer = buffer << 1;
      802:  200:      buffer |= nbit;
      802:  201:    } else {
      969:  202:      sleft(&result);
      969:  203:      s21_touchbit(&result, 1, 0);
      969:  204:      int nbit = s21_getbit(dec, fone - i + 1);
      969:  205:      buffer = buffer << 1;
      969:  206:      buffer |= nbit;
        -:  207:    }
     1771:  208:  }
        -:  209:
       43:  210:  buffer = buffer >> 1;
       43:  211:  *dec = result;
       43:  212:  s21_touchbit(dec, 128, sign);
       43:  213:  set_cap(dec, scalenum - 1);
        -:  214:
       43:  215:  return buffer;
        -:  216:}
        -:  217:
       55:  218:int first1(s21_decimal *dec) {
       55:  219:  int first1 = -1;
     3624:  220:  for (int i = 96; (i > 0) && (first1 == -1); i--) {
     3569:  221:    if (s21_getbit(dec, i) == 1) {
       55:  222:      first1 = i;
       55:  223:    }
     3569:  224:  }
       55:  225:  return first1;
        -:  226:}
        -:  227:
     1934:  228:void sleft(s21_decimal *dec) {
     1934:  229:  dec->bits[2] = dec->bits[2] << 1;
     1934:  230:  s21_touchbit(dec, 65, s21_getbit(dec, 64));
     1934:  231:  dec->bits[1] = dec->bits[1] << 1;
     1934:  232:  s21_touchbit(dec, 33, s21_getbit(dec, 32));
     1934:  233:  dec->bits[0] = dec->bits[0] << 1;
     1934:  234:}
        -:  235:
       56:  236:int x10dec(s21_decimal *dec1) {
       56:  237:  int addbit = 0;
       56:  238:  int result = 0;
        -:  239:
        -:  240:  s21_decimal dec3;
       56:  241:  dec3.bits[0] = 0;
       56:  242:  dec3.bits[1] = 0;
       56:  243:  dec3.bits[2] = 0;
       56:  244:  dec3.bits[3] = 0;
        -:  245:
       56:  246:  if (get_cap(dec1) < 28) {
     5432:  247:    for (int i = 1; i <= 96; i++) {
     5376:  248:      int sum = s21_getmbit(dec1, i - 1) + s21_getmbit(dec1, i - 3) + addbit;
     5376:  249:      if (sum == 0) {
     4531:  250:        s21_touchbit(&dec3, i, 0);
     4531:  251:        addbit = 0;
     4531:  252:      }
     5376:  253:      if (sum == 1) {
      438:  254:        s21_touchbit(&dec3, i, 1);
      438:  255:        addbit = 0;
      438:  256:      }
     5376:  257:      if (sum == 2) {
      290:  258:        s21_touchbit(&dec3, i, 0);
      290:  259:        addbit = 1;
      290:  260:      }
     5376:  261:      if (sum == 3) {
      117:  262:        s21_touchbit(&dec3, i, 1);
      117:  263:        addbit = 1;
      117:  264:      }
     5376:  265:    }
      280:  266:    for (int i = 94; i <= 97; i++) {
      224:  267:      int sum = s21_getmbit(dec1, i) + s21_getmbit(dec1, i + 2) + addbit;
      224:  268:      if (sum == 0) {
      224:  269:        s21_touchbit(&dec3, i + 3, 0);
      224:  270:        addbit = 0;
      224:  271:      }
      224:  272:      if (sum == 1) {
    #####:  273:        s21_touchbit(&dec3, i + 3, 1);
    #####:  274:        addbit = 0;
    #####:  275:      }
      224:  276:      if (sum == 2) {
    #####:  277:        s21_touchbit(&dec3, i + 3, 0);
    #####:  278:        addbit = 1;
    #####:  279:      }
      224:  280:      if (sum == 3) {
    #####:  281:        s21_touchbit(&dec3, i + 3, 1);
    #####:  282:        addbit = 1;
    #####:  283:      }
      224:  284:    }
      112:  285:    if ((s21_getbit(&dec3, 97) == 0) && (s21_getbit(&dec3, 98) == 0) &&
       56:  286:        (s21_getbit(&dec3, 99) == 0) && (s21_getbit(&dec3, 100) == 0)) {
     5656:  287:      for (int i = 1; i <= 100; i++) {
     5600:  288:        s21_touchbit(dec1, i, s21_getbit(&dec3, i));
     5600:  289:      }
       56:  290:      int cap = get_cap(dec1) + 1;
       56:  291:      set_cap(dec1, cap);
       56:  292:    } else
    #####:  293:      result = 1;
       56:  294:  } else
    #####:  295:    result = 1;
       56:  296:  return result;
        -:  297:}
        -:  298:
       67:  299:int getsig(s21_decimal *dec) { return s21_getbit(dec, 128); }
        -:  300:
        6:  301:unsigned int remdivx10(s21_decimal *dec) {
        6:  302:  unsigned int buffer = 0;
        -:  303:
        6:  304:  int sign = getsig(dec);
        6:  305:  int scalenum = get_cap(dec);
        6:  306:  s21_decimal result = {{0, 0, 0, 0}};
        -:  307:
        6:  308:  int fone = first1(dec);
        -:  309:
       53:  310:  for (int i = 0; i < fone + 2; i++) {
       47:  311:    if (buffer >= 10) {
        6:  312:      sleft(&result);
        6:  313:      s21_touchbit(&result, 1, 1);
        6:  314:      buffer = buffer - 10u;
        6:  315:      int nbit = s21_getbit(dec, fone - i + 1);
        6:  316:      buffer = buffer << 1;
        6:  317:      buffer |= nbit;
        6:  318:    } else {
       41:  319:      sleft(&result);
       41:  320:      s21_touchbit(&result, 1, 0);
       41:  321:      int nbit = s21_getbit(dec, fone - i + 1);
       41:  322:      buffer = buffer << 1;
       41:  323:      buffer |= nbit;
        -:  324:    }
       47:  325:  }
        -:  326:
        6:  327:  buffer = buffer >> 1;
        6:  328:  *dec = result;
        6:  329:  s21_touchbit(dec, 128, sign);
        6:  330:  set_cap(dec, scalenum);
        -:  331:
        6:  332:  return buffer;
        -:  333:}
        -:  334:
        1:  335:int increase_mant_1(s21_decimal *dec) {
        -:  336:  s21_decimal res;
        1:  337:  res.bits[0] = 0;
        1:  338:  res.bits[1] = 0;
        1:  339:  res.bits[2] = 0;
        1:  340:  res.bits[3] = 0;
        1:  341:  int result = 1;
        1:  342:  int incr_ok = 0;
        1:  343:  int i = 1;
        2:  344:  while ((incr_ok == 0) && (i <= 96)) {
        1:  345:    if (s21_getbit(dec, i) == 1) {
    #####:  346:      s21_touchbit(&res, i, 0);
    #####:  347:    } else {
        1:  348:      s21_touchbit(&res, i, 1);
        1:  349:      incr_ok = 1;
        -:  350:    }
        1:  351:    i++;
        -:  352:  }
       96:  353:  while ((i <= 96)) {
       95:  354:    s21_touchbit(&res, i, s21_getbit(dec, i));
       95:  355:    i++;
        -:  356:  }
        1:  357:  if (incr_ok == 1) {
        1:  358:    *dec = res;
        1:  359:    result = 0;
        1:  360:  }
        -:  361:
        1:  362:  return result;
        -:  363:}
        -:  364:
    #####:  365:int bank_rounding_div10(s21_decimal *dec) {
    #####:  366:  int norm_bit = 0;
    #####:  367:  int buffer = remdivx10(dec);
    #####:  368:  if ((buffer > 5) || ((buffer == 5) && (s21_getbit(dec, 1) == 1))) {
    #####:  369:    increase_mant_1(dec);
    #####:  370:  }
        -:  371:
    #####:  372:  if (buffer == 5) {
    #####:  373:    norm_bit = 1;
    #####:  374:  }
    #####:  375:  return norm_bit;
        -:  376:}
        -:  377:
      137:  378:int normalize(s21_decimal *dec1, s21_decimal *dec2) {
      137:  379:  int cap1 = get_cap(dec1);
      137:  380:  int cap2 = get_cap(dec2);
      137:  381:  int diffcap = cap1 - cap2;
      137:  382:  int decok = 0;
      137:  383:  int norm_bit = 0;
      137:  384:  if (diffcap > 0) {  // Если у первого числа длиннее разрядность, т.е. степень
        -:  385:                      // делителя больше
       56:  386:    while (
       28:  387:        (diffcap > 0) && (cap2 < 28) &&
       26:  388:        (decok ==
        -:  389:         0)) {  // Сначала умножаем на десять второе число и дробь(+1 к разряду)
       26:  390:      decok = x10dec(dec2);  // Пока не забили всю мантиссу
       26:  391:      if (decok == 0) {
       26:  392:        diffcap--;
       26:  393:        cap2++;
       26:  394:      }
        -:  395:    }
        2:  396:    while (diffcap >
        -:  397:           0) {  // Начинаем делить второе число на десять и уменьшать степень
    #####:  398:      norm_bit = bank_rounding_div10(dec1);
    #####:  399:      diffcap--;
    #####:  400:      cap1--;
        -:  401:    }
        2:  402:    while (diffcap > 0) {  // Если не нормализовали к этому моменту, то второе
        -:  403:                           // число просто делим на 10 с банковским округлением
    #####:  404:      norm_bit = bank_rounding_div10(dec1);
    #####:  405:      diffcap--;
        -:  406:    }
        2:  407:  }
      137:  408:  if (diffcap < 0) {  // Если у второго числа больше разрядность, т.е. выше
        -:  409:                      // степень делителя
       52:  410:    while ((diffcap < 0) && (cap1 < 28) &&
       24:  411:           (decok == 0)) {  // Сначала умножаем на десять число и дробь первого
        -:  412:                            // числа(+1 к разряду)
       24:  413:      decok = x10dec(dec1);
       24:  414:      if (decok == 0) {
       24:  415:        diffcap++;
       24:  416:        cap1++;
       24:  417:      }
        -:  418:    }
        4:  419:    while (diffcap <
        -:  420:           0) {  // Начинаем делить второе число на десять и уменьшать степень
    #####:  421:      norm_bit = bank_rounding_div10(dec2);
    #####:  422:      diffcap++;
    #####:  423:      cap2--;
        -:  424:    }
        4:  425:    while (diffcap > 0) {  // Если не нормализовали к этому моменту, то второе
        -:  426:                           // число просто делим на 10 с банковским округлением
    #####:  427:      norm_bit = bank_rounding_div10(dec2);
    #####:  428:      diffcap++;
        -:  429:    }
        4:  430:  }
      137:  431:  set_cap(dec1, cap1);
      137:  432:  set_cap(dec2, cap2);
      137:  433:  return norm_bit;
        -:  434:}
        -:  435:
    96298:  436:int s21_getbit(s21_decimal *dec,
        -:  437:               int num) {  //  Возвращает бит децимала(1 или 0)
    96298:  438:  int result = 0;
    96298:  439:  if (num <= 32) {
    26312:  440:    if (dec->bits[0] & (1 << (num - 1))) {
     2290:  441:      result = 1;
     2290:  442:    }
    26312:  443:  }
    96298:  444:  if ((num > 32) && (num <= 64)) {
    28668:  445:    if (dec->bits[1] & (1 << (num - 33))) {
      676:  446:      result = 1;
      676:  447:    }
    28668:  448:  }
    96298:  449:  if ((num > 64) && (num <= 96)) {
    30451:  450:    if (dec->bits[2] & (1 << (num - 65))) {
      344:  451:      result = 1;
      344:  452:    }
    30451:  453:  }
    96298:  454:  if (num > 96) {
    10867:  455:    if (dec->bits[3] & (1 << (num - 97))) {
      625:  456:      result = 1;
      625:  457:    }
    10867:  458:  }
    96298:  459:  return result;
        -:  460:}
        -:  461:
    11200:  462:int s21_getmbit(s21_decimal *dec,
        -:  463:                int num) {  //  Возвращает бит мантиссы децимала(1 или 0), если
        -:  464:                            //  бит не из мантиссы, то ноль.
    11200:  465:  int result = 0;
    11200:  466:  if ((num <= 32) && (num >= 1)) {
     3584:  467:    if (dec->bits[0] & (1 << (num - 1))) {
      820:  468:      result = 1;
      820:  469:    }
     3584:  470:  }
    11200:  471:  if ((num > 32) && (num <= 64)) {
     3584:  472:    if (dec->bits[1] & (1 << (num - 33))) {
      142:  473:      result = 1;
      142:  474:    }
     3584:  475:  }
    11200:  476:  if ((num > 64) && (num <= 96)) {
     3584:  477:    if (dec->bits[2] & (1 << (num - 65))) {
    #####:  478:      result = 1;
    #####:  479:    }
     3584:  480:  }
    11200:  481:  return result;
        -:  482:}
        -:  483:
    23416:  484:void s21_touchbit(s21_decimal *dec, int num,
        -:  485:                  int bit) {  //  Устанавливает бит в децимал(1 или 0)
    23416:  486:  if (num <= 32) {
     6274:  487:    if (bit == 1) {
     1822:  488:      dec->bits[0] |= (1 << (num - 1));
     1822:  489:    } else {
     4452:  490:      dec->bits[0] &= ~(1 << (num - 1));
        -:  491:    }
     6274:  492:  }
    23416:  493:  if ((num > 32) && (num <= 64)) {
     6388:  494:    if (bit == 1) {
      581:  495:      dec->bits[1] |= (1 << (num - 33));
      581:  496:    } else {
     5807:  497:      dec->bits[1] &= ~(1 << (num - 33));
        -:  498:    }
     6388:  499:  }
    23416:  500:  if ((num > 64) && (num <= 96)) {
     6382:  501:    if (bit == 1) {
      108:  502:      dec->bits[2] |= (1 << (num - 65));
      108:  503:    } else {
     6274:  504:      dec->bits[2] &= ~(1 << (num - 65));
        -:  505:    }
     6382:  506:  }
    23416:  507:  if (num > 96) {
     4372:  508:    if (bit == 1) {
      347:  509:      dec->bits[3] |= (1 << (num - 97));
      347:  510:    } else {
     4025:  511:      dec->bits[3] &= ~(1 << (num - 97));
        -:  512:    }
     4372:  513:  }
    23416:  514:}
        -:  515:
     3400:  516:int getmbit(s21_decimal *dec,
        -:  517:            int num) {  //  Возвращает бит мантиссы децимала(1 или 0), если
        -:  518:                        //  бит не из мантиссы, то ноль.
     3400:  519:  int result = 0;
     3400:  520:  if ((num <= 32) && (num >= 1)) {
     1088:  521:    if (dec->bits[0] & (1 << (num - 1))) {
      382:  522:      result = 1;
      382:  523:    }
     1088:  524:  }
     3400:  525:  if ((num > 32) && (num <= 64)) {
     1088:  526:    if (dec->bits[1] & (1 << (num - 33))) {
      218:  527:      result = 1;
      218:  528:    }
     1088:  529:  }
     3400:  530:  if ((num > 64) && (num <= 96)) {
     1088:  531:    if (dec->bits[2] & (1 << (num - 65))) {
       10:  532:      result = 1;
       10:  533:    }
     1088:  534:  }
     3400:  535:  return result;
        -:  536:}
        -:  537:
    27308:  538:int getbit(s21_decimal *dec,
        -:  539:           int num) {  //  Возвращает бит децимала(1 или 0)
    27308:  540:  int result = 0;
    27308:  541:  if (num <= 32) {
     9140:  542:    if (dec->bits[0] & (1 << (num - 1))) {
     3700:  543:      result = 1;
     3700:  544:    }
     9140:  545:  }
    27308:  546:  if ((num > 32) && (num <= 64)) {
     9024:  547:    if (dec->bits[1] & (1 << (num - 33))) {
     3443:  548:      result = 1;
     3443:  549:    }
     9024:  550:  }
    27308:  551:  if ((num > 64) && (num <= 96)) {
     9024:  552:    if (dec->bits[2] & (1 << (num - 65))) {
     3277:  553:      result = 1;
     3277:  554:    }
     9024:  555:  }
    27308:  556:  if (num > 96) {
      120:  557:    if (dec->bits[3] & (1 << (num - 97))) {
       21:  558:      result = 1;
       21:  559:    }
      120:  560:  }
    27308:  561:  return result;
        -:  562:}
        -:  563:
      552:  564:int get_cap(s21_decimal *dec) {  //  Возвращает разрядность децимала или -1,
        -:  565:                                 //  если превышена 28
     1656:  566:  int capacity = 1 * s21_getbit(dec, 113) + 2 * s21_getbit(dec, 114) +
     1656:  567:                 4 * s21_getbit(dec, 115) + 8 * s21_getbit(dec, 116) +
     1656:  568:                 16 * s21_getbit(dec, 117) + 32 * s21_getbit(dec, 118) +
     1104:  569:                 64 * s21_getbit(dec, 119) + 168 * s21_getbit(dec, 120);
      552:  570:  if (capacity > 28) {
    #####:  571:    capacity = -1;
    #####:  572:  }
      552:  573:  return capacity;
        -:  574:}
        -:  575:
      478:  576:int set_cap(s21_decimal *dec,
        -:  577:            int cap) {  //  Устанавливает разрядность в децимал
     4302:  578:  for (int n = 0; n < 8; n++) {
     3824:  579:    if (cap % 2 == 1) {
      298:  580:      s21_touchbit(dec, 113 + n, 1);
      298:  581:      cap = cap - 1;
      298:  582:    } else {
     3526:  583:      s21_touchbit(dec, 113 + n, 0);
        -:  584:    }
     3824:  585:    cap = cap / 2;
     3824:  586:  }
      478:  587:  return 0;
        -:  588:}
        -:  589:
     5140:  590:void touchbit(s21_decimal *dec, int num,
        -:  591:              int bit) {  //  Устанавливает бит в децимал(1 или 0)
     5140:  592:  if (num <= 32) {
     1815:  593:    if (bit == 1) {
      583:  594:      dec->bits[0] |= (1 << (num - 1));
      583:  595:    } else {
     1232:  596:      dec->bits[0] &= ~(1 << (num - 1));
        -:  597:    }
     1815:  598:  }
     5140:  599:  if ((num > 32) && (num <= 64)) {
     1536:  600:    if (bit == 1) {
      273:  601:      dec->bits[1] |= (1 << (num - 33));
      273:  602:    } else {
     1263:  603:      dec->bits[1] &= ~(1 << (num - 33));
        -:  604:    }
     1536:  605:  }
     5140:  606:  if ((num > 64) && (num <= 96)) {
     1536:  607:    if (bit == 1) {
       24:  608:      dec->bits[2] |= (1 << (num - 65));
       24:  609:    } else {
     1512:  610:      dec->bits[2] &= ~(1 << (num - 65));
        -:  611:    }
     1536:  612:  }
     5140:  613:  if (num > 96) {
      253:  614:    if (bit == 1) {
       16:  615:      dec->bits[3] |= (1 << (num - 97));
       16:  616:    } else {
      237:  617:      dec->bits[3] &= ~(1 << (num - 97));
        -:  618:    }
      253:  619:  }
     5140:  620:}
        -:  621:
        -:  622:// Преобразование из int в s21_decimal
       29:  623:int s21_from_int_to_decimal(int src, s21_decimal *dst) {
       29:  624:  if (dst == NULL) {
    #####:  625:    return 1;
        -:  626:  }
        -:  627:
       29:  628:  mmemset(dst, 0, sizeof(s21_decimal));
       29:  629:  int sign = 0;
        -:  630:
       29:  631:  if (src < 0) {
        8:  632:    sign = 1;
        8:  633:    src = -src;
        8:  634:  }
        -:  635:
       29:  636:  dst->bits[0] = src;
       29:  637:  if (sign) {
        8:  638:    dst->bits[3] |= 1U << 31;
        8:  639:  }
        -:  640:
       29:  641:  return 0;
       29:  642:}
        -:  643:
        -:  644:// Преобразование из s21_decimal в int
       17:  645:int s21_from_decimal_to_int(s21_decimal src, int *dst) {
       17:  646:  if (dst == NULL) {
    #####:  647:    return 1;
        -:  648:  }
        -:  649:
       17:  650:  int sign = (src.bits[3] >> 31) & 1U;
       17:  651:  int absValue = src.bits[0];
       17:  652:  if (sign) {
        6:  653:    absValue = -absValue;
        6:  654:  }
        -:  655:
       17:  656:  *dst = absValue;
       17:  657:  return 0;
       17:  658:}
        -:  659:
       29:  660:void *mmemset(void *ptr, int value, size_t num) {
       29:  661:  unsigned char *p = ptr;
      493:  662:  for (size_t i = 0; i < num; ++i) {
      464:  663:    *p++ = (unsigned char)value;
      464:  664:  }
       29:  665:  return ptr;
        -:  666:}
        -:  667:
       11:  668:int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
       11:  669:  result->bits[0] = 0;
       11:  670:  result->bits[1] = 0;
       11:  671:  result->bits[2] = 0;
       11:  672:  result->bits[3] = 0;
       11:  673:  int sign1 = s21_getbit(&value_1, 128);
       11:  674:  int sign2 = s21_getbit(&value_2, 128);
       11:  675:  touchbit(&value_1, 128, 0);
       11:  676:  touchbit(&value_2, 128, 0);
       11:  677:  int error = 0;
       11:  678:  if (sign1 == 0 && sign2 == 0) {
        7:  679:    error = adder(&value_1, &value_2, result);
        7:  680:  }
       11:  681:  if (sign1 == 0 && sign2 == 1) {
        1:  682:    if (s21_is_greater_or_equal(value_1, value_2) == 1) {
        1:  683:      deadder(&value_1, &value_2, result);
        1:  684:    } else {
    #####:  685:      deadder(&value_2, &value_1, result);
    #####:  686:      s21_negate(*result, result);
        -:  687:    }
        1:  688:  }
       11:  689:  if (sign1 == 1 && sign2 == 0) {
        1:  690:    if (s21_is_greater_or_equal(value_2, value_1) == 1) {
    #####:  691:      deadder(&value_2, &value_1, result);
    #####:  692:    } else {
        1:  693:      deadder(&value_1, &value_2, result);
        1:  694:      s21_negate(*result, result);
        -:  695:    }
        1:  696:  }
       11:  697:  if (sign1 == 1 && sign2 == 1) {
        2:  698:    error = (adder(&value_1, &value_2, result) * 2);
        2:  699:    s21_negate(*result, result);
        2:  700:  }
       11:  701:  return error;
        -:  702:}
        -:  703:
       23:  704:int s21_sub(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
       23:  705:  result->bits[0] = 0;
       23:  706:  result->bits[1] = 0;
       23:  707:  result->bits[2] = 0;
       23:  708:  result->bits[3] = 0;
        -:  709:
       23:  710:  int sign1 = s21_getbit(&value_1, 128);
       23:  711:  int sign2 = s21_getbit(&value_2, 128);
       23:  712:  touchbit(&value_1, 128, 0);
       23:  713:  touchbit(&value_2, 128, 0);
       23:  714:  int error = 0;
       23:  715:  if (sign1 == 0 && sign2 == 0) {
       18:  716:    if (s21_is_greater_or_equal(value_1, value_2) == 1) {
       15:  717:      deadder(&value_1, &value_2, result);
       15:  718:    } else {
        3:  719:      deadder(&value_2, &value_1, result);
        -:  720:      // s21_negate(*result, result);
        3:  721:      touchbit(result, 128, 1);
        -:  722:    }
       18:  723:  }
       23:  724:  if (sign1 == 0 && sign2 == 1) {
        2:  725:    error = adder(&value_1, &value_2, result);
        2:  726:  }
       23:  727:  if (sign1 == 1 && sign2 == 0) {
        3:  728:    error = (adder(&value_1, &value_2, result) * 2);
        -:  729:    // s21_negate(*result, result);
        3:  730:    touchbit(result, 128, 1);
        3:  731:  }
       23:  732:  if (sign1 == 1 && sign2 == 1) {
    #####:  733:    if (s21_is_greater_or_equal(value_2, value_1) == 1) {
    #####:  734:      deadder(&value_2, &value_1, result);
    #####:  735:    } else {
    #####:  736:      deadder(&value_1, &value_2, result);
        -:  737:      // s21_negate(*result, result);
    #####:  738:      touchbit(result, 128, 1);
        -:  739:    }
    #####:  740:  }
        -:  741:
        -:  742:  // printf("\n");
        -:  743:  // for (int i = 128; i > 0; i--) {
        -:  744:  //   printf("%d", getbit(&value_1, i));
        -:  745:  // }
        -:  746:  // printf("\n");
        -:  747:  // for (int i = 128; i > 0; i--) {
        -:  748:  //   printf("%d", getbit(&value_2, i));
        -:  749:  // }
        -:  750:
       23:  751:  return error;
        -:  752:}
        -:  753:
        7:  754:int s21_negate(s21_decimal value, s21_decimal *result) {
        7:  755:  *result = value;
        7:  756:  if (s21_getbit(&value, 128) == 0) {
        5:  757:    s21_touchbit(result, 128, 1);
        5:  758:  } else {
        2:  759:    s21_touchbit(result, 128, 0);
        -:  760:  }
        7:  761:  return 0;
        -:  762:}
        -:  763:
       20:  764:int deadder(s21_decimal *dec1, s21_decimal *dec2, s21_decimal *dec3) {
       20:  765:  int norm_bit = 0;
       20:  766:  dec3->bits[0] = 0;
       20:  767:  dec3->bits[1] = 0;
       20:  768:  dec3->bits[2] = 0;
       20:  769:  dec3->bits[3] = 0;
       20:  770:  int error = 0;
       20:  771:  norm_bit = normalize(dec1, dec2);
       20:  772:  int sum = 0;
       20:  773:  int addbit = 0;
     1940:  774:  for (int i = 1; i <= 96; i++) {
     1920:  775:    sum = s21_getbit(dec1, i) - s21_getbit(dec2, i) - addbit;
     1920:  776:    if (sum == 1) {
      149:  777:      s21_touchbit(dec3, i, 1);
      149:  778:      addbit = 0;
      149:  779:    }
     1920:  780:    if (sum == 0) {
     1721:  781:      s21_touchbit(dec3, i, 0);
     1721:  782:      addbit = 0;
     1721:  783:    }
     1920:  784:    if (sum == -1) {
       41:  785:      s21_touchbit(dec3, i, 1);
       41:  786:      addbit = 1;
       41:  787:    }
     1920:  788:    if (sum == -2) {
        9:  789:      s21_touchbit(dec3, i, 0);
        9:  790:      addbit = 1;
        9:  791:    }
     1920:  792:  }
       20:  793:  set_cap(dec3, get_cap(dec1));
       20:  794:  return error;
        -:  795:}
        -:  796:
       14:  797:int adder(s21_decimal *dec1, s21_decimal *dec2, s21_decimal *dec3) {
       14:  798:  int norm_bit = 0;
       14:  799:  dec3->bits[0] = 0;
       14:  800:  dec3->bits[1] = 0;
       14:  801:  dec3->bits[2] = 0;
       14:  802:  dec3->bits[3] = 0;
        -:  803:
       14:  804:  susper_decimal sdec = {{0, 0, 0, 0, 0, 0, 0, 0}};
       14:  805:  int error = 0;
       14:  806:  norm_bit = normalize(dec1, dec2);
       14:  807:  set_cap(dec3, get_cap(dec1));
       14:  808:  int sum = 0;
       14:  809:  int addbit = 0;
     1358:  810:  for (int i = 1; i <= 96; i++) {
     1344:  811:    sum = getbit(dec1, i) + getbit(dec2, i) + addbit;
     1344:  812:    if (sum == 0) {
      792:  813:      sd_touchbit(&sdec, i, 0);
      792:  814:      addbit = 0;
      792:  815:    }
     1344:  816:    if (sum == 1) {
       74:  817:      sd_touchbit(&sdec, i, 1);
       74:  818:      addbit = 0;
       74:  819:    }
     1344:  820:    if (sum == 2) {
      461:  821:      sd_touchbit(&sdec, i, 0);
      461:  822:      addbit = 1;
      461:  823:    }
     1344:  824:    if (sum == 3) {
       17:  825:      sd_touchbit(&sdec, i, 1);
       17:  826:      addbit = 1;
       17:  827:    }
     1344:  828:  }
        -:  829:
       14:  830:  if (addbit == 1) {
        4:  831:    sd_touchbit(&sdec, 97, 1);
        4:  832:  }
        -:  833:
       14:  834:  if (sd_getbit(&sdec, 97) == 1) {
        4:  835:    if ((get_cap(dec1) > 0)) {
    #####:  836:      sd_bank_rounding_div10(&sdec);
    #####:  837:      for (int i = 1; i <= 96; i++) {
    #####:  838:        touchbit(dec3, i, sd_getbit(&sdec, i));
    #####:  839:      }
    #####:  840:      set_cap(dec3, get_cap(dec1) - 1);
        -:  841:
    #####:  842:    } else {
        4:  843:      error = 1;
        -:  844:    }
        4:  845:  }
     1358:  846:  for (int i = 1; i <= 96; i++) {
     1344:  847:    touchbit(dec3, i, sd_getbit(&sdec, i));
     1344:  848:  }
        -:  849:
       14:  850:  if ((norm_bit == 1) && (getbit(dec3, 1) == 1)) {
    #####:  851:    increase_mant_1(dec3);
    #####:  852:  }
        -:  853:
       14:  854:  return error;
        -:  855:}
        -:  856:
        6:  857:void sright(s21_decimal *dec) {
        6:  858:  dec->bits[0] = dec->bits[0] >> 1;
        6:  859:  s21_touchbit(dec, 32, s21_getbit(dec, 33));
        6:  860:  dec->bits[1] = dec->bits[1] >> 1;
        6:  861:  s21_touchbit(dec, 64, s21_getbit(dec, 65));
        6:  862:  dec->bits[2] = dec->bits[2] >> 1;
        6:  863:}
        -:  864:
       28:  865:int is_zero(s21_decimal *dec) {
       28:  866:  int result = 0;
       28:  867:  if (dec->bits[0] == dec->bits[1] == dec->bits[2] == 0) {
       15:  868:    result = 1;
       15:  869:  }
       28:  870:  return result;
        -:  871:}
        -:  872:
        9:  873:int s21_div(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
        -:  874:  // normalize(&value_1, &value_2);
        9:  875:  int error = 0;
        -:  876:
        9:  877:  s21_decimal buffer = {{0, 0, 0, 0}};
        9:  878:  s21_decimal tempresult = {{0, 0, 0, 0}};
        9:  879:  result->bits[0] = 0;
        9:  880:  result->bits[1] = 0;
        9:  881:  result->bits[2] = 0;
        9:  882:  result->bits[3] = 0;
        -:  883:
        9:  884:  int sign1 = getsig(&value_1);
        9:  885:  int sign2 = getsig(&value_2);
        9:  886:  int cap1 = get_cap(&value_1);
        9:  887:  int cap2 = get_cap(&value_2);
        9:  888:  int addcap = 0;
        9:  889:  s21_decimal devider = {{0, 0, 0, 0}};
        9:  890:  touchbit(&value_1, 128, 0);
        9:  891:  touchbit(&value_2, 128, 0);
        -:  892:
        9:  893:  devider = value_1;
        -:  894:  // buffer = value_1;
        9:  895:  int counter = 0;
        9:  896:  if (is_zero(&value_2)) {
        2:  897:    error = 3;
        2:  898:  } else {
       13:  899:    while ((is_zero(&devider) != 1) && (counter < 29)) {
        6:  900:      tempresult.bits[0] = tempresult.bits[1] = tempresult.bits[2] =
        6:  901:          tempresult.bits[3] = 0;
        6:  902:      buffer.bits[0] = buffer.bits[1] = buffer.bits[2] = buffer.bits[3] = 0;
        -:  903:      // while (is_zero(&buffer) != 1) {
        6:  904:      int fone = first1(&devider);
        -:  905:
       64:  906:      for (int i = 0; i < fone + 2; i++) {
       58:  907:        if (s21_is_greater_or_equal(
        -:  908:                buffer,
        -:  909:                value_2)) {  // s21_is_greater_or_equal buf val2
       13:  910:          sleft(&tempresult);
       13:  911:          touchbit(&tempresult, 1, 1);
       13:  912:          s21_sub(buffer, value_2, &buffer);  // sub buff val2
       13:  913:          int nbit = getbit(&devider, fone - i + 1);
       13:  914:          sleft(&buffer);  // lefts buff
       13:  915:          if ((getbit(&buffer, 1) == 1) ||
       13:  916:              (nbit == 1)) {  //   I 1 bit || nbit ==1 touch 1
        3:  917:            touchbit(&buffer, 1, 1);
        3:  918:          }
        -:  919:          //
       13:  920:        } else {
       45:  921:          sleft(&tempresult);
       45:  922:          touchbit(&tempresult, 1, 0);
       45:  923:          int nbit = getbit(&devider, fone - i + 1);
       45:  924:          sleft(&buffer);
       45:  925:          if ((getbit(&buffer, 1) == 1) ||
       45:  926:              (nbit == 1)) {  //   I 1 bit || nbit ==1 touch 1
       15:  927:            touchbit(&buffer, 1, 1);
       15:  928:          }
        -:  929:        }
       58:  930:      }
        6:  931:      sright(&buffer);  // rightshift ?
        -:  932:                        // for (int i = 128; i > 0; i--) {
        -:  933:                        //   printf("%d", getbit(&buffer, i));
        -:  934:                        // }
        -:  935:                        // printf("\n");
        -:  936:
        -:  937:      // printf(" - buffer\n");
        6:  938:      if (is_zero(&buffer) != 1) {
    #####:  939:        addcap++;
    #####:  940:        x10dec(&buffer);
    #####:  941:      }
        6:  942:      x10dec(result);
        -:  943:
        6:  944:      adder_wo_normalize(result, &tempresult, result);
        -:  945:      // adder(result, &tempresult, result);
        -:  946:
        6:  947:      devider = buffer;  //   Теперь делитель - это бывший остаток
        -:  948:
        6:  949:      if (((cap1 - cap2 + addcap) >= 0) && (cap1 - cap2 + addcap) < 29) {  //
        6:  950:        set_cap(result, (cap1 - cap2 + addcap));
        6:  951:      }
        6:  952:      while ((cap1 - cap2 + addcap) < 0) {
    #####:  953:        x10dec(result);
    #####:  954:        addcap++;
        -:  955:      }
        6:  956:      while ((cap1 - cap2 + addcap) >= 29) {
    #####:  957:        bank_rounding_div10(result);
    #####:  958:        addcap--;
    #####:  959:        counter++;
        -:  960:      }
        -:  961:    }
        -:  962:
        7:  963:    set_cap(result, cap1 - cap2 + addcap);
        -:  964:
        7:  965:    if (((sign1 == 0) && (sign2 == 0)) || ((sign1 == 1) && (sign2 == 1))) {
        7:  966:      touchbit(result, 128, 0);
        7:  967:    } else {
       14:  968:      touchbit(result, 128, 1);
        -:  969:    }
        -:  970:
        -:  971:    // *dec = result;
        -:  972:    // touchbit(result, 128, sign);
        -:  973:    // set_cap(result, scalenum - 1); // setcap cap1-cap2 if <0 divx10 n если
        -:  974:    // выходим за мантиссу, то в зависимости от знака 2 или 3 в ошибку
        -:  975:  }
        9:  976:  return error;
        -:  977:}
        -:  978:
        6:  979:int adder_wo_normalize(s21_decimal *dec1, s21_decimal *dec2,
        -:  980:                       s21_decimal *dec3) {
        6:  981:  dec3->bits[0] = 0;
        6:  982:  dec3->bits[1] = 0;
        6:  983:  dec3->bits[2] = 0;
        6:  984:  dec3->bits[3] = 0;
        6:  985:  int error = 0;
        6:  986:  int sum = 0;
        6:  987:  int addbit = 0;
      582:  988:  for (int i = 1; i <= 96; i++) {
      576:  989:    sum = s21_getbit(dec1, i) + s21_getbit(dec2, i) + addbit;
      576:  990:    if (sum == 0) {
      563:  991:      s21_touchbit(dec3, i, 0);
      563:  992:      addbit = 0;
      563:  993:    }
      576:  994:    if (sum == 1) {
       13:  995:      s21_touchbit(dec3, i, 1);
       13:  996:      addbit = 0;
       13:  997:    }
      576:  998:    if (sum == 2) {
    #####:  999:      s21_touchbit(dec3, i, 0);
    #####: 1000:      addbit = 1;
    #####: 1001:    }
      576: 1002:    if (sum == 3) {
    #####: 1003:      s21_touchbit(dec3, i, 1);
    #####: 1004:      addbit = 1;
    #####: 1005:    }
      576: 1006:  }
        6: 1007:  return 0;
        -: 1008:}
        -: 1009:
       17: 1010:void x10mant(s21_decimal *dec1) {
       17: 1011:  int addbit = 0;
        -: 1012:
       17: 1013:  s21_decimal dec3 = {0, 0, 0, 0};
       17: 1014:  dec3.bits[0] = 0;
       17: 1015:  dec3.bits[1] = 0;
       17: 1016:  dec3.bits[2] = 0;
       17: 1017:  dec3.bits[3] = 0;
        -: 1018:
     1649: 1019:  for (int i = 1; i <= 96; i++) {
     1632: 1020:    int sum = getmbit(dec1, i - 1) + getmbit(dec1, i - 3) + addbit;
     1632: 1021:    if (sum == 0) {
     1082: 1022:      touchbit(&dec3, i, 0);
     1082: 1023:      addbit = 0;
     1082: 1024:    }
     1632: 1025:    if (sum == 1) {
      273: 1026:      touchbit(&dec3, i, 1);
      273: 1027:      addbit = 0;
      273: 1028:    }
     1632: 1029:    if (sum == 2) {
      217: 1030:      touchbit(&dec3, i, 0);
      217: 1031:      addbit = 1;
      217: 1032:    }
     1632: 1033:    if (sum == 3) {
       60: 1034:      touchbit(&dec3, i, 1);
       60: 1035:      addbit = 1;
       60: 1036:    }
     1632: 1037:  }
       85: 1038:  for (int i = 94; i <= 97; i++) {
       68: 1039:    int sum = getmbit(dec1, i) + getmbit(dec1, i + 2) + addbit;
       68: 1040:    if (sum == 0) {
       68: 1041:      touchbit(&dec3, i + 3, 0);
       68: 1042:      addbit = 0;
       68: 1043:    }
       68: 1044:    if (sum == 1) {
    #####: 1045:      touchbit(&dec3, i + 3, 1);
    #####: 1046:      addbit = 0;
    #####: 1047:    }
       68: 1048:    if (sum == 2) {
    #####: 1049:      touchbit(&dec3, i + 3, 0);
    #####: 1050:      addbit = 1;
    #####: 1051:    }
       68: 1052:    if (sum == 3) {
    #####: 1053:      touchbit(&dec3, i + 3, 1);
    #####: 1054:      addbit = 1;
    #####: 1055:    }
       68: 1056:  }
     1717: 1057:  for (int i = 1; i <= 100; i++) {
     1700: 1058:    touchbit(dec1, i, getbit(&dec3, i));
     1700: 1059:  }
       17: 1060:}
        -: 1061:
    26719: 1062:int sd_getbit(susper_decimal *dec,
        -: 1063:              int num) {  //  Возвращает бит супердецимала
    26719: 1064:  int result = 0;
    26719: 1065:  if ((num <= 32) && (num >= 1)) {
     2653: 1066:    if (dec->bits[0] & (1 << (num - 1))) {
      612: 1067:      result = 1;
      612: 1068:    }
     2653: 1069:  }
    26719: 1070:  if ((num > 32) && (num <= 64)) {
     4960: 1071:    if (dec->bits[1] & (1 << (num - 33))) {
     1539: 1072:      result = 1;
     1539: 1073:    }
     4960: 1074:  }
    26719: 1075:  if ((num > 64) && (num <= 96)) {
     7008: 1076:    if (dec->bits[2] & (1 << (num - 65))) {
     2548: 1077:      result = 1;
     2548: 1078:    }
     7008: 1079:  }
    26719: 1080:  if ((num > 96) && (num <= 128)) {
     5760: 1081:    if (dec->bits[3] & (1 << (num - 97))) {
     2453: 1082:      result = 1;
     2453: 1083:    }
     5760: 1084:  }
    26719: 1085:  if ((num > 128) && (num <= 160)) {
     3584: 1086:    if (dec->bits[4] & (1 << (num - 129))) {
     1520: 1087:      result = 1;
     1520: 1088:    }
     3584: 1089:  }
    26719: 1090:  if ((num > 160) && (num <= 192)) {
     1538: 1091:    if (dec->bits[5] & (1 << (num - 161))) {
      498: 1092:      result = 1;
      498: 1093:    }
     1538: 1094:  }
    26719: 1095:  if ((num > 192) && (num <= 224)) {
      608: 1096:    if (dec->bits[6] & (1 << (num - 193))) {
    #####: 1097:      result = 1;
    #####: 1098:    }
      608: 1099:  }
    26719: 1100:  if ((num > 224) && (num <= 256)) {
      608: 1101:    if (dec->bits[7] & (1 << (num - 225))) {
    #####: 1102:      result = 1;
    #####: 1103:    }
      608: 1104:  }
        -: 1105:
    26719: 1106:  return result;
        -: 1107:}
        -: 1108:
    22467: 1109:void sd_touchbit(susper_decimal *dec, int num,
        -: 1110:                 int bit) {  //  Устанавливает бит в децимал(1 или 0)
    22467: 1111:  if (num <= 32) {
     2254: 1112:    if (bit == 1) {
      634: 1113:      dec->bits[0] |= (1 << (num - 1));
      634: 1114:    } else {
     1620: 1115:      dec->bits[0] &= ~(1 << (num - 1));
        -: 1116:    }
     2254: 1117:  }
    22467: 1118:  if ((num > 32) && (num <= 64)) {
     4416: 1119:    if (bit == 1) {
     1539: 1120:      dec->bits[1] |= (1 << (num - 33));
     1539: 1121:    } else {
     2877: 1122:      dec->bits[1] &= ~(1 << (num - 33));
        -: 1123:    }
     4416: 1124:  }
    22467: 1125:  if ((num > 64) && (num <= 96)) {
     6464: 1126:    if (bit == 1) {
     2548: 1127:      dec->bits[2] |= (1 << (num - 65));
     2548: 1128:    } else {
     3916: 1129:      dec->bits[2] &= ~(1 << (num - 65));
        -: 1130:    }
     6464: 1131:  }
    22467: 1132:  if ((num > 96) && (num <= 128)) {
     5237: 1133:    if (bit == 1) {
     2484: 1134:      dec->bits[3] |= (1 << (num - 97));
     2484: 1135:    } else {
     2753: 1136:      dec->bits[3] &= ~(1 << (num - 97));
        -: 1137:    }
     5237: 1138:  }
    22467: 1139:  if ((num > 128) && (num <= 160)) {
     3072: 1140:    if (bit == 1) {
     1552: 1141:      dec->bits[4] |= (1 << (num - 129));
     1552: 1142:    } else {
     1520: 1143:      dec->bits[4] &= ~(1 << (num - 129));
        -: 1144:    }
     3072: 1145:  }
    22467: 1146:  if ((num > 160) && (num <= 192)) {
     1024: 1147:    if (bit == 1) {
      528: 1148:      dec->bits[5] |= (1 << (num - 161));
      528: 1149:    } else {
      496: 1150:      dec->bits[5] &= ~(1 << (num - 161));
        -: 1151:    }
     1024: 1152:  }
    22467: 1153:  if ((num > 192) && (num <= 224)) {
    #####: 1154:    if (bit == 1) {
    #####: 1155:      dec->bits[6] |= (1 << (num - 193));
    #####: 1156:    } else {
    #####: 1157:      dec->bits[6] &= ~(1 << (num - 193));
        -: 1158:    }
    #####: 1159:  }
    22467: 1160:  if ((num > 224) && (num <= 256)) {
    #####: 1161:    if (bit == 1) {
    #####: 1162:      dec->bits[7] |= (1 << (num - 225));
    #####: 1163:    } else {
    #####: 1164:      dec->bits[7] &= ~(1 << (num - 225));
        -: 1165:    }
    #####: 1166:  }
    22467: 1167:}
        -: 1168:
       19: 1169:int sd_first1(susper_decimal *dec) {
       19: 1170:  int first1 = -1;
     4356: 1171:  for (int i = 256; (i > 0) && (first1 == -1); i--) {
     4337: 1172:    if (sd_getbit(dec, i) == 1) {
       18: 1173:      first1 = i;
       18: 1174:    }
     4337: 1175:  }
       19: 1176:  return first1;
        -: 1177:}
        -: 1178:
       18: 1179:int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
        -: 1180:  susper_decimal sdec;
       18: 1181:  sdec.bits[0] = 0;
       18: 1182:  sdec.bits[1] = 0;
       18: 1183:  sdec.bits[2] = 0;
       18: 1184:  sdec.bits[3] = 0;
       18: 1185:  sdec.bits[4] = 0;
       18: 1186:  sdec.bits[5] = 0;
       18: 1187:  sdec.bits[6] = 0;
       18: 1188:  sdec.bits[7] = 0;
        -: 1189:
       18: 1190:  result->bits[0] = 0;
       18: 1191:  result->bits[1] = 0;
       18: 1192:  result->bits[2] = 0;
       18: 1193:  result->bits[3] = 0;
        -: 1194:
        -: 1195:  // printf("\n");
        -: 1196:  // for (int i = 128; i > 0; i--) {
        -: 1197:  //   printf("%d", getbit(&value_1, i));
        -: 1198:  // }
        -: 1199:  // printf("\n");
        -: 1200:  // for (int i = 128; i > 0; i--) {
        -: 1201:  //   printf("%d", getbit(&value_2, i));
        -: 1202:  // }
        -: 1203:  // printf("\n");
       18: 1204:  int error = 0;
       18: 1205:  int sumcap = get_cap(&value_1) + get_cap(&value_2);
     1746: 1206:  for (int i = 1; i <= 96; i++) {
     1728: 1207:    if (getbit(&value_1, i) == 1) {
      219: 1208:      int addbit = 0;
    21243: 1209:      for (int j = 1; j <= 96; j++) {
    21024: 1210:        int sum = sd_getbit(&sdec, j + i - 1) + getbit(&value_2, j) + addbit;
    21024: 1211:        if (sum == 0) {
    11715: 1212:          sd_touchbit(&sdec, i + j - 1, 0);
    11715: 1213:          addbit = 0;
    11715: 1214:        }
    21024: 1215:        if (sum == 1) {
      165: 1216:          sd_touchbit(&sdec, i + j - 1, 1);
      165: 1217:          addbit = 0;
      165: 1218:        }
    21024: 1219:        if (sum == 2) {
      214: 1220:          sd_touchbit(&sdec, i + j - 1, 0);
      214: 1221:          addbit = 1;
      214: 1222:        }
    21024: 1223:        if (sum == 3) {
     8930: 1224:          sd_touchbit(&sdec, i + j - 1, 1);
     8930: 1225:          addbit = 1;
     8930: 1226:        }
    21024: 1227:      }
      219: 1228:      if (addbit == 1) {
       95: 1229:        sd_touchbit(&sdec, i + 96, 1);
       95: 1230:      }
      219: 1231:    }
     1728: 1232:  }
       38: 1233:  while (
       19: 1234:      (sd_first1(&sdec) > 96) &&
        2: 1235:      (error ==
        -: 1236:       0)) {  //  Если супердец залезает за мантиссу обычного децимала. Режем.
        1: 1237:    if (sumcap > 0) {
    #####: 1238:      sd_bank_rounding_div10(&sdec);
    #####: 1239:      sumcap--;
    #####: 1240:    } else {
        2: 1241:      if (((getbit(&value_1, 128) == 1) && (getbit(&value_2, 128) == 1)) ||
        2: 1242:          ((getbit(&value_1, 128) == 0) && (getbit(&value_2, 128) == 0))) {
        1: 1243:        error = 1;
        1: 1244:      } else {
        2: 1245:        error = 2;
        -: 1246:      }
        -: 1247:    }
        -: 1248:  }
       18: 1249:  if (error == 0) {
       17: 1250:    while (sumcap > 28)  //  Денормализуем степень, если она больше 28
        -: 1251:    {
    #####: 1252:      sd_bank_rounding_div10(&sdec);
    #####: 1253:      sumcap--;
        -: 1254:    }
        -: 1255:
       17: 1256:    result->bits[0] = sdec.bits[0];
       17: 1257:    result->bits[1] = sdec.bits[1];
       17: 1258:    result->bits[2] = sdec.bits[2];
       17: 1259:    set_cap(result, sumcap);
       24: 1260:    if (((getbit(&value_1, 128) == 1) && (getbit(&value_2, 128) == 1)) ||
        9: 1261:        ((getbit(&value_1, 128) == 0) && (getbit(&value_2, 128) == 0))) {
        8: 1262:      touchbit(result, 128, 0);
        8: 1263:    } else {
        9: 1264:      touchbit(result, 128, 1);
        -: 1265:    }
        -: 1266:    // }
       17: 1267:  }
        -: 1268:  // for (int i = 128; i > 0; i--) {
        -: 1269:  //   printf("%d", getbit(result, i));
        -: 1270:  // }
        -: 1271:  // printf("\n");
        -: 1272:  // for (int i = 256; i >= 1; i--) {
        -: 1273:  //   printf("%d", sd_getbit(&sdec, i));
        -: 1274:  // }
        -: 1275:  // printf("\n");
        -: 1276:  // printf("%d\n", error);
       18: 1277:  return error;
        -: 1278:
        -: 1279:  // for (int i = 256; i >= 1; i--) {
        -: 1280:  //   printf("%d", sd_getbit(&sdec, i));
        -: 1281:  // }
        -: 1282:  // printf("\n");
        -: 1283:}
        -: 1284:
    #####: 1285:unsigned int sd_divx10(susper_decimal *dec) {
    #####: 1286:  unsigned int buffer = 0;
        -: 1287:
    #####: 1288:  susper_decimal result = {{0, 0, 0, 0, 0, 0, 0, 0}};
    #####: 1289:  result.bits[0] = 0;
    #####: 1290:  result.bits[1] = 0;
    #####: 1291:  result.bits[2] = 0;
    #####: 1292:  result.bits[3] = 0;
    #####: 1293:  result.bits[4] = 0;
    #####: 1294:  result.bits[5] = 0;
    #####: 1295:  result.bits[6] = 0;
    #####: 1296:  result.bits[7] = 0;
        -: 1297:
    #####: 1298:  int fone = sd_first1(dec);
        -: 1299:
    #####: 1300:  for (int i = 0; i < fone + 2; i++) {
    #####: 1301:    if (buffer >= 10) {
    #####: 1302:      sd_sleft(&result);
    #####: 1303:      sd_touchbit(&result, 1, 1);
    #####: 1304:      buffer = buffer - 10u;
    #####: 1305:      int nbit = sd_getbit(dec, fone - i + 1);
    #####: 1306:      buffer = buffer << 1;
    #####: 1307:      buffer |= nbit;
    #####: 1308:    } else {
    #####: 1309:      sd_sleft(&result);
    #####: 1310:      sd_touchbit(&result, 1, 0);
    #####: 1311:      int nbit = sd_getbit(dec, fone - i + 1);
    #####: 1312:      buffer = buffer << 1;
    #####: 1313:      buffer |= nbit;
        -: 1314:    }
    #####: 1315:  }
        -: 1316:
    #####: 1317:  buffer = buffer >> 1;
    #####: 1318:  *dec = result;
    #####: 1319:  return buffer;
        -: 1320:}
        -: 1321:
    #####: 1322:void sd_sleft(susper_decimal *dec) {
    #####: 1323:  dec->bits[7] = dec->bits[7] << 1;
    #####: 1324:  sd_touchbit(dec, 225, sd_getbit(dec, 224));
    #####: 1325:  dec->bits[6] = dec->bits[6] << 1;
    #####: 1326:  sd_touchbit(dec, 193, sd_getbit(dec, 192));
    #####: 1327:  dec->bits[5] = dec->bits[5] << 1;
    #####: 1328:  sd_touchbit(dec, 161, sd_getbit(dec, 160));
    #####: 1329:  dec->bits[4] = dec->bits[4] << 1;
    #####: 1330:  sd_touchbit(dec, 129, sd_getbit(dec, 128));
    #####: 1331:  dec->bits[3] = dec->bits[3] << 1;
    #####: 1332:  sd_touchbit(dec, 97, sd_getbit(dec, 96));
    #####: 1333:  dec->bits[2] = dec->bits[2] << 1;
    #####: 1334:  sd_touchbit(dec, 65, sd_getbit(dec, 64));
    #####: 1335:  dec->bits[1] = dec->bits[1] << 1;
    #####: 1336:  sd_touchbit(dec, 33, sd_getbit(dec, 32));
    #####: 1337:  dec->bits[0] = dec->bits[0] << 1;
    #####: 1338:}
        -: 1339:
    #####: 1340:void sd_bank_rounding_div10(susper_decimal *dec) {
    #####: 1341:  int buffer = sd_divx10(dec);
    #####: 1342:  if ((buffer > 5) || ((buffer == 5) && (sd_getbit(dec, 1) == 1))) {
    #####: 1343:    sd_increase_mant_1(dec);
    #####: 1344:  }
    #####: 1345:}
        -: 1346:
    #####: 1347:int sd_increase_mant_1(susper_decimal *dec) {
    #####: 1348:  susper_decimal res = {0, 0, 0, 0, 0, 0, 0, 0};
    #####: 1349:  int result = 1;
    #####: 1350:  int incr_ok = 0;
    #####: 1351:  int i = 1;
    #####: 1352:  while ((incr_ok == 0) && (i <= 256)) {
    #####: 1353:    if (sd_getbit(dec, i) == 1) {
    #####: 1354:      sd_touchbit(&res, i, 0);
    #####: 1355:    } else {
    #####: 1356:      sd_touchbit(&res, i, 1);
    #####: 1357:      incr_ok = 1;
        -: 1358:    }
    #####: 1359:    i++;
        -: 1360:  }
    #####: 1361:  while ((i <= 256)) {
    #####: 1362:    sd_touchbit(&res, i, sd_getbit(dec, i));
    #####: 1363:    i++;
        -: 1364:  }
    #####: 1365:  if (incr_ok == 1) {
    #####: 1366:    *dec = res;
    #####: 1367:    result = 0;
    #####: 1368:  }
        -: 1369:
    #####: 1370:  return result;
        -: 1371:}
        -: 1372:
        4: 1373:int s21_floor(s21_decimal value, s21_decimal *result) {
        4: 1374:  result->bits[0] = 0;
        4: 1375:  result->bits[1] = 0;
        4: 1376:  result->bits[2] = 0;
        4: 1377:  result->bits[3] = 0;
        4: 1378:  int remainder = 0;
        4: 1379:  int cap = get_cap(&value);
        4: 1380:  int sig = s21_getbit(&value, 128);
        6: 1381:  for (int i = 0; i < cap; i++) {
        2: 1382:    remainder = remdivx10(&value);
        2: 1383:  }
        4: 1384:  if (sig == 1) {
        1: 1385:    increase_mant_1(&value);
        1: 1386:  }
        -: 1387:
        4: 1388:  *result = value;
        4: 1389:  set_cap(result, 0);
        4: 1390:  s21_touchbit(result, 128, sig);
        4: 1391:  return 0;
        -: 1392:}
        -: 1393:
        5: 1394:int s21_round(s21_decimal value, s21_decimal *result) {
        5: 1395:  result->bits[0] = 0;
        5: 1396:  result->bits[1] = 0;
        5: 1397:  result->bits[2] = 0;
        5: 1398:  result->bits[3] = 0;
        5: 1399:  int remainder = 0;
        5: 1400:  int cap = get_cap(&value);
        5: 1401:  int sig = s21_getbit(&value, 128);
        9: 1402:  for (int i = 0; i < cap; i++) {
        4: 1403:    remainder = remdivx10(&value);
        4: 1404:  }
        5: 1405:  if ((remainder > 5) || ((remainder == 5) && (s21_getbit(&value, 1) == 1))) {
    #####: 1406:    increase_mant_1(&value);
    #####: 1407:  }
        -: 1408:
        5: 1409:  *result = value;
        5: 1410:  set_cap(result, 0);
        5: 1411:  s21_touchbit(result, 128, sig);
        5: 1412:  return 0;
        -: 1413:}
        -: 1414:
       16: 1415:int s21_from_decimal_to_float(s21_decimal dec, float *res) {
       16: 1416:  int result = 0;
        -: 1417:  int sign;
       16: 1418:  double temp = 0.0;
     1552: 1419:  for (int i = 1; i < 97; i++) {
     1536: 1420:    temp += (s21_getbit(&dec, i) * pow(2, i - 1));
     1536: 1421:  }
        -: 1422:
       16: 1423:  int exp = get_cap(&dec);
       16: 1424:  *res = temp / pow(10, exp);
        -: 1425:
       16: 1426:  if (s21_getbit(&dec, 128) == 1)
        8: 1427:    sign = -1;
        -: 1428:  else
        8: 1429:    sign = 1;
       16: 1430:  *res *= sign;
       16: 1431:  return result;
        -: 1432:}
